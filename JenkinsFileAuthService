// ==========================================
// PIPELINE GEN√âRICA PARA MICROSERVICIOS SPRING BOOT
// ==========================================

pipeline {
    agent any

    tools {
        maven 'Maven'
    }

    triggers {
        githubPush()
    }

    options {
        disableConcurrentBuilds()
        timeout(time: 45, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '15'))
    }

    // üîß PAR√ÅMETROS CONFIGURABLES POR MICROSERVICIO
    parameters {
        string(
            name: 'SERVICE_NAME',
            defaultValue: '',
            description: 'Nombre del microservicio (ej: user-service, product-service). Si est√° vac√≠o, se detecta autom√°ticamente.'
        )
        string(
            name: 'JAR_NAME',
            defaultValue: '',
            description: 'Nombre del archivo JAR (ej: userService-0.0.1-SNAPSHOT.jar). Si est√° vac√≠o, se detecta autom√°ticamente.'
        )
        string(
            name: 'SERVICE_PATH',
            defaultValue: '',
            description: 'Ruta personalizada en el servidor. Si est√° vac√≠o, usa /home/ubuntu/[SERVICE_NAME]'
        )
        choice(
            name: 'JAVA_VERSION',
            choices: ['21', '17', '11'],
            description: 'Versi√≥n de Java a usar'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Saltar ejecuci√≥n de tests'
        )
        booleanParam(
            name: 'FORCE_DEPLOY',
            defaultValue: false,
            description: 'Forzar deploy incluso en ramas de feature'
        )
    }

    environment {
        // Detecci√≥n autom√°tica de rama y estrategia
        BRANCH_NAME = "${env.GIT_BRANCH?.replaceAll('origin/', '') ?: env.BRANCH_NAME ?: 'dev'}"
        ENV = "${env.BRANCH_NAME == 'main' ? 'prod' : env.BRANCH_NAME}"

        // Configuraci√≥n de servidores EC2
        EC2_USER = 'ubuntu'
        EC2_IP_DEV = '23.22.115.242'
        EC2_IP_QA = '3.220.122.151'
        EC2_IP_PROD = '34.224.192.38'

        // Credenciales y herramientas
        SSH_KEY = credentials('ssh-key-ec2')
        JDK_DIR = "${WORKSPACE}/jdk${params.JAVA_VERSION}"
        JAVA_HOME = "${JDK_DIR}"
        PATH = "${JDK_DIR}/bin:${PATH}"

        // Variables que se calculan din√°micamente
        CALCULATED_SERVICE_NAME = ""
        CALCULATED_JAR_NAME = ""
        CALCULATED_SERVICE_PATH = ""
        DEPLOY_STRATEGY = ""
        TARGET_ENV = ""
    }

    stages {
        stage('üîç Auto-Detection & Setup') {
            steps {
                script {
                    echo "üîç [SETUP] Iniciando detecci√≥n autom√°tica..."

                    // 1. Detectar nombre del servicio
                    if (params.SERVICE_NAME?.trim()) {
                        env.CALCULATED_SERVICE_NAME = params.SERVICE_NAME.trim()
                        echo "‚úÖ [SETUP] Nombre del servicio (par√°metro): ${env.CALCULATED_SERVICE_NAME}"
                    } else {
                        // Intentar detectar desde pom.xml
                        try {
                            def pomContent = readFile('pom.xml')
                            echo "üîç [SETUP] Contenido POM: ${pomContent?.take(500)}"

                            if (pomContent && pomContent.trim()) {
                                // Buscar el artifactId del proyecto (no del parent)
                                def lines = pomContent.split('\n')
                                boolean inProject = false
                                boolean foundParent = false

                                for (line in lines) {
                                    if (line.contains('<parent>')) {
                                        foundParent = true
                                        continue
                                    }
                                    if (foundParent && line.contains('</parent>')) {
                                        foundParent = false
                                        inProject = true
                                        continue
                                    }
                                    if (!foundParent && line.contains('<artifactId>')) {
                                        def artifactIdMatch = line =~ /<artifactId>([^<]+)<\/artifactId>/
                                        if (artifactIdMatch) {
                                            env.CALCULATED_SERVICE_NAME = artifactIdMatch[0][1]
                                            break
                                        }
                                    }
                                }

                                if (!env.CALCULATED_SERVICE_NAME) {
                                    // Fallback: usar cualquier artifactId
                                    def artifactIdMatch = pomContent =~ /<artifactId>([^<]+)<\/artifactId>/
                                    if (artifactIdMatch) {
                                        env.CALCULATED_SERVICE_NAME = artifactIdMatch[0][1]
                                    }
                                }

                                echo "‚úÖ [SETUP] Nombre detectado desde pom.xml: ${env.CALCULATED_SERVICE_NAME}"
                            } else {
                                env.CALCULATED_SERVICE_NAME = "microservice-app"
                                echo "‚ö†Ô∏è [SETUP] POM vac√≠o o null, usando nombre por defecto: ${env.CALCULATED_SERVICE_NAME}"
                            }
                        } catch (Exception e) {
                            env.CALCULATED_SERVICE_NAME = "microservice-app"
                            echo "‚ö†Ô∏è [SETUP] Error leyendo pom.xml: ${e.message}, usando: ${env.CALCULATED_SERVICE_NAME}"
                        }

                        // Validar que no sea null
                        if (!env.CALCULATED_SERVICE_NAME) {
                            env.CALCULATED_SERVICE_NAME = "microservice-app"
                            echo "‚ö†Ô∏è [SETUP] SERVICE_NAME era null, usando fallback: ${env.CALCULATED_SERVICE_NAME}"
                        }
                    }

                    // 2. Detectar nombre del JAR
                    if (params.JAR_NAME?.trim()) {
                        env.CALCULATED_JAR_NAME = params.JAR_NAME.trim()
                    } else {
                        env.CALCULATED_JAR_NAME = "${env.CALCULATED_SERVICE_NAME}-0.0.1-SNAPSHOT.jar"
                    }
                    echo "üì¶ [SETUP] JAR esperado: ${env.CALCULATED_JAR_NAME}"

                    // 3. Calcular ruta del servicio
                    if (params.SERVICE_PATH?.trim()) {
                        env.CALCULATED_SERVICE_PATH = params.SERVICE_PATH.trim()
                    } else {
                        env.CALCULATED_SERVICE_PATH = "/home/ubuntu/${env.CALCULATED_SERVICE_NAME}"
                    }
                    echo "üìÅ [SETUP] Ruta del servicio: ${env.CALCULATED_SERVICE_PATH}"

                    // 4. Determinar estrategia de deploy
                    if (params.FORCE_DEPLOY) {
                        echo "üöÄ [SETUP] ESTRATEGIA: Deploy forzado"
                        env.DEPLOY_STRATEGY = 'auto'
                        env.TARGET_ENV = env.ENV
                    } else if (env.BRANCH_NAME == 'dev') {
                        echo "üöÄ [SETUP] ESTRATEGIA: Deploy autom√°tico a DEV"
                        env.DEPLOY_STRATEGY = 'auto'
                        env.TARGET_ENV = 'dev'
                    } else if (env.BRANCH_NAME == 'qa') {
                        echo "üîÑ [SETUP] ESTRATEGIA: Deploy autom√°tico a QA"
                        env.DEPLOY_STRATEGY = 'auto'
                        env.TARGET_ENV = 'qa'
                    } else if (env.BRANCH_NAME == 'main') {
                        echo "‚ö†Ô∏è [SETUP] ESTRATEGIA: Aprobaci√≥n manual + Deploy a PROD"
                        env.DEPLOY_STRATEGY = 'manual-approval'
                        env.TARGET_ENV = 'prod'
                    } else {
                        echo "‚úèÔ∏è [SETUP] ESTRATEGIA: Solo compilaci√≥n"
                        env.DEPLOY_STRATEGY = 'compile-only'
                        env.TARGET_ENV = 'none'
                    }

                    echo """
üéØ [SETUP] CONFIGURACI√ìN FINAL:
   ‚Ä¢ Servicio: ${env.CALCULATED_SERVICE_NAME}
   ‚Ä¢ JAR: ${env.CALCULATED_JAR_NAME}
   ‚Ä¢ Ruta: ${env.CALCULATED_SERVICE_PATH}
   ‚Ä¢ Rama: ${env.BRANCH_NAME}
   ‚Ä¢ Entorno: ${env.TARGET_ENV}
   ‚Ä¢ Estrategia: ${env.DEPLOY_STRATEGY}
   ‚Ä¢ Java: ${params.JAVA_VERSION}
   ‚Ä¢ Puerto: Configurado en Config Server
"""
                }
            }
        }

        stage('üîß Setup JDK') {
            when {
                not { environment name: 'DEPLOY_STRATEGY', value: 'skip' }
            }
            steps {
                script {
                    def javaVersion = params.JAVA_VERSION ?: '21'
                    def downloadUrl = ""

                    switch(javaVersion) {
                        case '21':
                            downloadUrl = "https://github.com/adoptium/temurin21-binaries/releases/download/jdk-21.0.2%2B13/OpenJDK21U-jdk_x64_linux_hotspot_21.0.2_13.tar.gz"
                            break
                        case '17':
                            downloadUrl = "https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.9%2B9/OpenJDK17U-jdk_x64_linux_hotspot_17.0.9_9.tar.gz"
                            break
                        case '11':
                            downloadUrl = "https://github.com/adoptium/temurin11-binaries/releases/download/jdk-11.0.21%2B9/OpenJDK11U-jdk_x64_linux_hotspot_11.0.21_9.tar.gz"
                            break
                        default:
                            downloadUrl = "https://github.com/adoptium/temurin21-binaries/releases/download/jdk-21.0.2%2B13/OpenJDK21U-jdk_x64_linux_hotspot_21.0.2_13.tar.gz"
                    }

                    echo "üîß [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Configurando JDK ${javaVersion}..."
                    sh """
                        mkdir -p \${JDK_DIR}

                        if [ ! -f \${JDK_DIR}/bin/java ]; then
                            echo "üì• [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Descargando JDK ${javaVersion}..."
                            wget -q "${downloadUrl}" -O jdk.tar.gz
                            tar -xzf jdk.tar.gz -C \${JDK_DIR} --strip-components=1
                            rm jdk.tar.gz
                            echo "‚úÖ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] JDK ${javaVersion} instalado"
                        else
                            echo "‚úÖ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] JDK ${javaVersion} ya existe"
                        fi

                        echo "‚òï [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Java version:"
                        \${JDK_DIR}/bin/java -version
                    """
                }
            }
        }

        stage('üî® Build Application') {
            when {
                not { environment name: 'DEPLOY_STRATEGY', value: 'skip' }
            }
            steps {
                sh """
                    export JAVA_HOME=\${JDK_DIR}
                    export PATH=\${JAVA_HOME}/bin:\$PATH

                    echo "üî® [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Compilando aplicaci√≥n..."

                    # Dar permisos de ejecuci√≥n a mvnw
                    chmod +x ./mvnw

                    # Limpiar y compilar
                    ./mvnw clean package ${params.SKIP_TESTS ? '-DskipTests' : ''} -q

                    # Buscar el JAR compilado (detecci√≥n autom√°tica)
                    JAR_FILE=\$(find target -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" | head -1)

                    if [ -n "\$JAR_FILE" ]; then
                        echo "‚úÖ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] JAR encontrado: \$JAR_FILE"
                        ls -lh "\$JAR_FILE"

                        # Actualizar variable de entorno con el JAR real encontrado
                        JAR_NAME=\$(basename "\$JAR_FILE")
                        echo "JAR_FOUND=\$JAR_NAME" > jar_info.txt
                    else
                        echo "‚ùå [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Error: No se encontr√≥ JAR"
                        echo "üîç Archivos en target/:"
                        ls -la target/ || echo "Directorio target no existe"
                        exit 1
                    fi
                """

                script {
                    // Leer el JAR encontrado y actualizar variables
                    try {
                        def jarInfo = readFile('jar_info.txt').trim()
                        env.CALCULATED_JAR_NAME = jarInfo.split('=')[1]
                        echo "‚úÖ [SETUP] JAR final detectado: ${env.CALCULATED_JAR_NAME}"
                    } catch (Exception e) {
                        def serviceName = env.CALCULATED_SERVICE_NAME ?: 'unknown-service'
                        env.CALCULATED_JAR_NAME = "${serviceName}-0.0.1-SNAPSHOT.jar"
                        echo "‚ö†Ô∏è [SETUP] Usando JAR por defecto: ${env.CALCULATED_JAR_NAME}"
                    }
                }
            }
        }

        stage('üß™ Tests') {
            when {
                allOf {
                    not { environment name: 'DEPLOY_STRATEGY', value: 'skip' }
                    expression { !params.SKIP_TESTS }
                }
            }
            steps {
                sh """
                    export JAVA_HOME=\${JDK_DIR}
                    export PATH=\${JAVA_HOME}/bin:\$PATH

                    echo "üß™ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Ejecutando tests..."
                    ./mvnw test -q || echo "‚ö†Ô∏è [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Tests fallaron, continuando..."
                """
            }
        }

        stage('‚ö†Ô∏è Production Approval') {
            when {
                environment name: 'DEPLOY_STRATEGY', value: 'manual-approval'
            }
            steps {
                script {
                    def serviceName = env.CALCULATED_SERVICE_NAME ?: 'unknown-service'
                    def branchName = env.BRANCH_NAME ?: 'unknown'
                    def buildNumber = env.BUILD_NUMBER ?: 'N/A'
                    def javaVersion = params.JAVA_VERSION ?: '21'

                    echo """
üö® [${serviceName}] APROBACI√ìN REQUERIDA PARA PRODUCCI√ìN

üìã Informaci√≥n del Deploy:
   ‚Ä¢ Servicio: ${serviceName}
   ‚Ä¢ Entorno: PRODUCCI√ìN
   ‚Ä¢ Rama: ${branchName}
   ‚Ä¢ Build: ${buildNumber}
   ‚Ä¢ Java: ${javaVersion}
   ‚Ä¢ Puerto: Definido en Config Server
"""

                    timeout(time: 15, unit: 'MINUTES') {
                        def approved = input(
                            message: "üö® ¬øAprobar deploy de ${serviceName} a PRODUCCI√ìN?",
                            ok: '‚úÖ Aprobar Deploy',
                            parameters: [
                                choice(
                                    name: 'ACTION',
                                    choices: ['Aprobar', 'Rechazar'],
                                    description: 'Selecciona la acci√≥n'
                                ),
                                text(
                                    name: 'COMMENTS',
                                    defaultValue: '',
                                    description: 'Comentarios adicionales (opcional)'
                                )
                            ]
                        )

                        if (approved != 'Aprobar') {
                            error("‚ùå [${serviceName}] Deploy a producci√≥n rechazado")
                        }

                        echo "‚úÖ [${serviceName}] Deploy a producci√≥n APROBADO"
                        if (params.COMMENTS?.trim()) {
                            echo "üí¨ Comentarios: ${params.COMMENTS}"
                        }
                    }
                }
            }
        }

        stage('üöÄ Deploy Microservice') {
            when {
                anyOf {
                    environment name: 'DEPLOY_STRATEGY', value: 'auto'
                    environment name: 'DEPLOY_STRATEGY', value: 'manual-approval'
                }
            }
            steps {
                script {
                    def EC2_IP = ''
                    def serviceName = (env.CALCULATED_SERVICE_NAME ?: 'unknown-service').replaceAll('[^a-zA-Z0-9-]', '-')
                    def servicePath = env.CALCULATED_SERVICE_PATH ?: '/home/ubuntu/microservice-app'
                    def targetEnv = env.TARGET_ENV ?: 'dev'
                    def envProfile = env.ENV ?: 'dev'

                    // Determinar IP seg√∫n entorno
                    if (targetEnv == 'prod') {
                        EC2_IP = env.EC2_IP_PROD
                    } else if (targetEnv == 'qa') {
                        EC2_IP = env.EC2_IP_QA
                    } else {
                        EC2_IP = env.EC2_IP_DEV
                    }

                    echo "üöÄ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Desplegando en ${targetEnv.toUpperCase()} (${EC2_IP})"

                    // 1. Preparar servidor
                    sh """
                    echo "üîß [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Preparando servidor..."
                    ssh -i \$SSH_KEY -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${EC2_USER}@${EC2_IP} '
                        # Crear directorios
                        sudo mkdir -p ${servicePath}
                        sudo chown -R ubuntu:ubuntu ${servicePath}

                        # Instalar dependencias b√°sicas
                        which curl > /dev/null || sudo apt-get update -qq && sudo apt-get install -y curl
                        which netstat > /dev/null || sudo apt-get install -y net-tools

                        # Instalar Java si no existe
                        if ! which java > /dev/null; then
                            echo "‚òï [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Instalando Java ${params.JAVA_VERSION}..."
                            sudo apt-get update -qq && sudo apt-get install -y openjdk-${params.JAVA_VERSION}-jre-headless
                        fi

                        echo "‚úÖ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Servidor preparado"
                    '
                    """

                    // 2. Detener servicio existente
                    sh """
                    echo "üõë [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Deteniendo servicio existente..."
                    ssh -i \$SSH_KEY -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} '
                        if sudo systemctl is-active --quiet ${serviceName}.service; then
                            echo "üõë Deteniendo servicio ${serviceName}..."
                            sudo systemctl stop ${serviceName}.service
                            sleep 5
                        else
                            echo "‚ÑπÔ∏è Servicio ${serviceName} no est√° corriendo"
                        fi
                    ' || echo "‚ö†Ô∏è [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] No hay servicio previo"
                    """

                    // 3. Copiar JAR
                    sh """
                    echo "üì¶ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Copiando JAR..."

                    # Buscar el JAR compilado din√°micamente
                    JAR_FILE=\$(find target -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" | head -1)

                    if [ -n "\$JAR_FILE" ]; then
                        echo "üì¶ Copiando JAR: \$JAR_FILE"
                        scp -i \$SSH_KEY -o StrictHostKeyChecking=no "\$JAR_FILE" ${EC2_USER}@${EC2_IP}:${servicePath}/app.jar
                        echo "‚úÖ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] JAR copiado como app.jar"
                    else
                        echo "‚ùå No se encontr√≥ JAR para copiar"
                        exit 1
                    fi
                    """

                    // 4. Crear servicio systemd
                    def systemdService = """[Unit]
Description=Spring Boot Microservice - ${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}
After=network.target
Wants=network-online.target
After=network-online.target

[Service]
Type=simple
User=ubuntu
Group=ubuntu
WorkingDirectory=${servicePath}
ExecStart=/usr/bin/java -jar ${servicePath}/app.jar \\
    --spring.profiles.active=${envProfile} \\
    --logging.level.root=INFO \\
    --logging.file.name=${servicePath}/${serviceName}.log

# Configuraci√≥n de reinicio
Restart=on-failure
RestartSec=10
SuccessExitStatus=143

# Logging
StandardOutput=journal
StandardError=journal
SyslogIdentifier=${serviceName}

# Seguridad
NoNewPrivileges=true
PrivateTmp=true

# Variables de entorno
Environment=JAVA_HOME=/usr/lib/jvm/java-${params.JAVA_VERSION}-openjdk-amd64
Environment=SPRING_PROFILES_ACTIVE=${envProfile}

[Install]
WantedBy=multi-user.target"""

                    // 5. Configurar e iniciar servicio
                    sh """
                    echo "‚öôÔ∏è [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Configurando servicio systemd..."

                    # Crear archivo de servicio
                    echo '${systemdService}' | ssh -i \$SSH_KEY -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} 'sudo tee /etc/systemd/system/${serviceName}.service > /dev/null'

                    # Configurar e iniciar servicio
                    ssh -i \$SSH_KEY -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} '
                        # Recargar systemd
                        sudo systemctl daemon-reload

                        # Habilitar auto-inicio
                        sudo systemctl enable ${serviceName}.service

                        # Iniciar servicio
                        sudo systemctl start ${serviceName}.service

                        # Verificar inicio
                        sleep 10
                        if sudo systemctl is-active --quiet ${serviceName}.service; then
                            echo "‚úÖ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Servicio iniciado correctamente"
                            sudo systemctl status ${serviceName}.service --no-pager -l
                        else
                            echo "‚ùå [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Error al iniciar servicio"
                            sudo systemctl status ${serviceName}.service --no-pager -l
                            sudo journalctl -u ${serviceName}.service --since \"5 minutes ago\" --no-pager
                            exit 1
                        fi
                    '
                    """

                    echo "‚úÖ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Deploy completado en ${targetEnv.toUpperCase()}!"
                }
            }
        }

        stage('üîç Health Check & Verification') {
            when {
                anyOf {
                    environment name: 'DEPLOY_STRATEGY', value: 'auto'
                    environment name: 'DEPLOY_STRATEGY', value: 'manual-approval'
                }
            }
            steps {
                script {
                    def EC2_IP = ''
                    def serviceName = (env.CALCULATED_SERVICE_NAME ?: 'unknown-service').replaceAll('[^a-zA-Z0-9-]', '-')

                    if (env.TARGET_ENV == 'prod') {
                        EC2_IP = env.EC2_IP_PROD
                    } else if (env.TARGET_ENV == 'qa') {
                        EC2_IP = env.EC2_IP_QA
                    } else {
                        EC2_IP = env.EC2_IP_DEV
                    }

                    echo "üîç [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Verificando deploy..."

                    // Esperar inicio completo
                    sh "sleep 30"

                    // Verificaciones completas
                    sh """
                    ssh -i \$SSH_KEY -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} '
                        echo "üìä [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Estado del servicio:"
                        sudo systemctl status ${serviceName}.service --no-pager

                        echo "üîå [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Detectando puerto del servicio..."
                        # Detectar el puerto que est√° usando el servicio
                        SERVICE_PORT=\$(sudo journalctl -u ${serviceName}.service --since \"5 minutes ago\" --no-pager | grep -o "Tomcat started on port(s): [0-9]*" | grep -o "[0-9]*" | tail -1)

                        if [ -z "\$SERVICE_PORT" ]; then
                            # Fallback: buscar cualquier puerto que est√© escuchando el proceso Java
                            SERVICE_PID=\$(sudo systemctl show --property MainPID --value ${serviceName}.service)
                            if [ "\$SERVICE_PID" != "0" ]; then
                                SERVICE_PORT=\$(sudo netstat -tlnp | grep "\$SERVICE_PID/java" | awk "{print \$4}" | cut -d: -f2 | head -1)
                            fi
                        fi

                        if [ -n "\$SERVICE_PORT" ]; then
                            echo "‚úÖ Puerto detectado: \$SERVICE_PORT"

                            echo "üè• [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Verificando health endpoint..."
                            for i in {1..12}; do
                                if curl -f http://localhost:\$SERVICE_PORT/actuator/health 2>/dev/null; then
                                    echo "‚úÖ Health Check: PASSED"
                                    curl -s http://localhost:\$SERVICE_PORT/actuator/health | head -5
                                    break
                                fi
                                echo "‚è≥ Esperando health endpoint... (\$i/12)"
                                sleep 10
                            done
                        else
                            echo "‚ö†Ô∏è No se pudo detectar el puerto del servicio"
                            echo "üîç Puertos activos:"
                            sudo netstat -tuln | grep LISTEN
                        fi

                        echo "üìÑ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] √öltimos logs:"
                        sudo journalctl -u ${serviceName}.service --since \"2 minutes ago\" --no-pager | tail -10

                        echo "‚úÖ [${env.CALCULATED_SERVICE_NAME ?: 'unknown-service'}] Verificaci√≥n completada"
                    '
                    """
                }
            }
        }
    }

    post {
        success {
            script {
                def serviceName = env.CALCULATED_SERVICE_NAME ?: 'unknown-service'
                def deployStrategy = env.DEPLOY_STRATEGY ?: 'N/A'
                def branchName = env.BRANCH_NAME ?: 'unknown'
                def targetEnv = env.TARGET_ENV ?: 'unknown'

                if (deployStrategy && deployStrategy != 'compile-only') {
                    def EC2_IP = ''
                    def cleanServiceName = serviceName.replaceAll('[^a-zA-Z0-9-]', '-')

                    if (targetEnv == 'prod') {
                        EC2_IP = env.EC2_IP_PROD
                    } else if (targetEnv == 'qa') {
                        EC2_IP = env.EC2_IP_QA
                    } else {
                        EC2_IP = env.EC2_IP_DEV
                    }

                    echo """
üéâ [${serviceName}] ¬°DEPLOY EXITOSO EN ${targetEnv.toUpperCase()}!

üìã Informaci√≥n del servicio:
   ‚Ä¢ Nombre: ${serviceName}
   ‚Ä¢ Servidor: ${EC2_IP}
   ‚Ä¢ Systemd Service: ${cleanServiceName}.service
   ‚Ä¢ Java Version: ${params.JAVA_VERSION}
   ‚Ä¢ Puerto: Configurado en Config Server

üåê Verificaci√≥n de salud:
   ‚Ä¢ El puerto se obtiene autom√°ticamente del Config Server
   ‚Ä¢ Health endpoint: http://${EC2_IP}:[PUERTO]/actuator/health
   ‚Ä¢ Info endpoint: http://${EC2_IP}:[PUERTO]/actuator/info

üõ†Ô∏è Comandos de gesti√≥n:
   ‚Ä¢ Estado: sudo systemctl status ${cleanServiceName}.service
   ‚Ä¢ Logs: sudo journalctl -u ${cleanServiceName}.service -f
   ‚Ä¢ Restart: sudo systemctl restart ${cleanServiceName}.service
   ‚Ä¢ Stop: sudo systemctl stop ${cleanServiceName}.service
   ‚Ä¢ Detectar puerto: sudo journalctl -u ${cleanServiceName}.service | grep "Tomcat started on port"

‚úÖ Auto-inicio habilitado
"""
                } else {
                    echo "‚úÖ [${serviceName}] Compilaci√≥n exitosa - Rama: ${branchName}"
                }
            }
        }

        failure {
            script {
                def serviceName = env.CALCULATED_SERVICE_NAME ?: 'unknown-service'
                def deployStrategy = env.DEPLOY_STRATEGY ?: 'N/A'
                def branchName = env.BRANCH_NAME ?: 'unknown'
                def buildNumber = env.BUILD_NUMBER ?: 'N/A'

                echo """
‚ùå [${serviceName}] PIPELINE FALLIDO

üîç Informaci√≥n:
   ‚Ä¢ Servicio: ${serviceName}
   ‚Ä¢ Rama: ${branchName}
   ‚Ä¢ Estrategia: ${deployStrategy}
   ‚Ä¢ Build: ${buildNumber}

üõ†Ô∏è Debug: sudo journalctl -u ${serviceName.replaceAll('[^a-zA-Z0-9-]', '-')}.service
"""
            }
        }

        cleanup {
            sh '''
                rm -rf jdk*.tar.gz jdk.tar.gz || true
                echo "‚úÖ Limpieza completada"
            '''
        }
    }
}